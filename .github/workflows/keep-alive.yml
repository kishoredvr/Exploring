name: Keep Supabase Alive

on:
  schedule:
    # 0 = Minute 0
    # 0 = Hour 0 (UTC Midnight)
    # * = Every day of month
    # * = Every month
    # 1,3,4,6 = Mon, Wed, Thu, Sat (Irregular schedule)
    - cron: "0 0 * * 1,3,4,6"
  workflow_dispatch:

# --- ADDED: Grant permission to write to the repository ---
permissions:
  contents: write

jobs:
  keepalive:
    runs-on: ubuntu-latest
    steps:
      # --- ADDED: Checkout code ---
      - uses: actions/checkout@v4

      # --- ADDED: Manual Keepalive Script (No external action) ---
      - name: Git Auto-Commit (Keepalive)
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # Get timestamp of the last commit
          last_commit=$(git log -1 --format=%ct)
          now=$(date +%s)
          seconds_since_last_commit=$((now - last_commit))
          
          # Threshold: 50 days (4320000 seconds)
          if [ $seconds_since_last_commit -gt 4320000 ]; then
            echo "Last commit was > 50 days ago. Pushing empty commit to reset GitHub timer."
            git commit --allow-empty -m "Automated keep-alive [skip ci]"
            git push
          else
            echo "Last commit was recent ($seconds_since_last_commit seconds ago). No action needed."
          fi

      - name: Send Keep-Alive Payload
        env:
          # REQUIRED: Add this in GitHub Repo Settings -> Secrets
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
        run: |
          # 1. Generate Dynamic Variables to prevent DB collisions
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          UNIQUE_ID="KEEPALIVE-$(date +%s)"

          echo "----------------------------------------"
          echo "Generated Run ID: $UNIQUE_ID"
          echo "Timestamp: $TIMESTAMP"
          echo "----------------------------------------"

          # 2. Construct JSON Payload securely (Heredoc)
          # We set purpose="Other" to trigger the email logic in your TS file.
          JSON_PAYLOAD=$(cat <<EOF
          {
            "name": "KeepAlive Bot",
            "email": "keepalive@system.bot",
            "mobileNumber": "9999999999",
            "purpose": "Other",
            "astroServiceSelect": "Not applicable",
            "astro_service_tier": "Not applicable",
            "birthDetailsAvailable": "Not applicable",
            "dob": "Not applicable",
            "hour": "Not applicable",
            "minute": "Not applicable",
            "second": "Not applicable",
            "explanation": "Not applicable",
            "city": "Not applicable",
            "state": "Not applicable",
            "country": "Not applicable",
            "pincode": "Not applicable",
            "gender": "Not applicable",
            "genderOtherInput": "Not applicable",
            "accuracy": "Not applicable",
            "contactCountry": "India",
            "expectations": "Automated keep-alive request $UNIQUE_ID",
            "phonepe_txn_id": "KA-TXN-0000",
            "phonepe_order_id": "$UNIQUE_ID",
            "payment_amount": "0",
            "payment_status": "not applicable",
            "submittedAt": "$TIMESTAMP"
          }
          EOF
          )

          # 3. Send Request and Capture Full Response
          # We use curl with headers to mimic a legitimate request.
          # The -w flag captures the HTTP status code at the end.
          response=$(curl -s -w "\n%{http_code}" -X POST "https://lkvcbpxkpwpoqjlcddgl.functions.supabase.co/submit-form" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
            -H "User-Agent: GitHub-Actions-KeepAlive/1.0" \
            -H "Accept: application/json" \
            --max-time 60 \
            -d "$JSON_PAYLOAD")

          # 4. Process Response
          http_body=$(echo "$response" | sed '$d')
          http_code=$(echo "$response" | tail -n1)

          echo "----------------------------------------"
          echo "SERVER RESPONSE BODY:"
          echo "$http_body"
          echo "----------------------------------------"
          echo "HTTP STATUS CODE: $http_code"

          # 5. Fail the workflow if not 200 OK
          if [ "$http_code" -ne 200 ]; then
            echo "::error::Request failed! Server returned status $http_code"
            exit 1
          fi

          # 6. Check if body implies success (Optional additional check)
          if [[ "$http_body" != *"success"* ]]; then
             echo "::warning::Server returned 200 but body does not contain 'success'. Check logs."
          fi
